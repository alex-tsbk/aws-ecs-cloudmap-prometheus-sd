{
  "DiscoveryOptions": {
    // Semicolon separated string of ECS clusters to include.
    // At least one of "EcsClusters" or "CloudMapNamespaces" must be provided.
    "EcsClusters": "cluster1;cluster2",
    // Semicolon separated string of tag key-value pairs to select ECS services.
    // If a selector is provided, service must match all tags in the selector.
    // If selector is not provided, all services in the clusters are included.
    // Tag value selector supports wildcard symbol: *.
    // Tags key/value matching is case-sensitive.
    // Example:
    //    Given the following selector: "service_discovery=true;component=app;other_tag=*;"
    //    All services with the tag "service_discovery" set to "true"
    //    and "component" set to "app"
    //    and "other_tag" set to any value will be included.
    // IMPORTANT:
    //    1. It is your responsibility to ensure that all tags are present on the resource
    //    2. If you specify 'CloudMapServiceSelectorTags' - it is your responsibility to ensure
    //       that ecs services and corresponding cloud map services are both included via selectors specified.
    "EcsServiceSelectorTags": "",
    // Semicolon separated string of CloudMap namespaces to include.
    // When 'EcsClusters' parameter is specified,
    // all ECS services that are using Service Connect are always included in lookup.
    // This parameter allows you to include additional namespaces to discover
    // services using AWS Service Discovery (legacy).
    "CloudMapNamespaces": "namespace1;namespace2",
    // Semicolon separated string of tag key-value pairs to select CloudMap services.
    // See comments to "EcsServiceSelectorTags" above for more information.
    // Example: "service_discovery=true;component=app"
    "CloudMapServiceSelectorTags": "",
    // Semicolon separated string of tag names to include in the service discovery response as metadata.
    // Supports glob pattern matching using * and ?.
    // Controls which tags are included in the service discovery response as metadata.
    // Because metadata labels are dictionary keys, they must be unique.
    // Therefore, tags are resolved in the following priority:
    // ECS Task > ECS Service > Cloud Map Service > Cloud Map Namespace
    // If no value is not provided, no tags will be included.
    // Example:
    //    Having "EcsTaskTags" set to "service_discovery;app_*"
    //    will include all tags with their values where kag 'Key'
    //    starts with "app_", and tag 'Key' equals "service_discovery".
    "EcsTaskTags": "*",
    "EcsServiceTags": "*",
    "CloudMapServiceTags": "*",
    "CloudMapNamespaceTags": "*",
    // Semicolon separated string of labels to include in the service discovery response as metadata.
    // Will be added to all discovered targets.
    // For example, "environment=dev;region=us-west-2"
    // If value needs to have a semicolon, or equals sign, it must be prefixed using %.
    // For example, "eval_expression=a%=%=b;components=a%;b%;;"
    // would be parsed as "eval_expression=a==b;components=a;b;"
    // Any label that is not a valid Prometheus label will be transformed to such.
    // Read more: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#labelname
    "ExtraPrometheusLabels": "",
    // Specifies the TTL for the cache of service discovery results.
    // Set to 0 to disable caching (request to AWS will be made upon every http request).
    "CacheTtlSeconds": 60,
    // Tag prefix to identify metrics path and port.
    // Must be at least three characters long and end with an underscore.
    // This prefix has a special meaning and is used to identify the metrics path and port
    // for the service. 'PATH', 'PORT', 'NAME' will be appended to the prefix to identify
    // metrics path, port, and container names respectively.
    // If your service contains multiple metrics paths
    // or ports, you can tag your resources using the following format:
    // * METRICS_PATH_1 = /metrics
    // * METRICS_PORT_1 = 9001
    // * METRICS_NAME_1 = application
    // * METRICS_PATH_2 = /metrics2
    // * METRICS_PORT_2 = 9002
    // * METRICS_NAME_2 = sidecar
    // ..etc.
    // System won't care of anything after _PATH, _PORT, or _NAME,
    // so as long as these postfixes are identical for triplets,
    // you can use any postfix (including empty) you prefer,
    // which makes the following combination valid:
    // * METRICS_PATH_SVC-ONE = /metrics
    // * METRICS_PORT_SVC-ONE = 9001
    // * METRICS_NAME_SVC-ONE = svc-one
    // as well as these:
    // * METRICS_PATH = /metrics
    // * METRICS_PORT = 9001
    // If a path is not provided, default path "/metrics" will be used.
    // If a name is not provided, the service name will be omitted from labels.
    // Here is an example of regex to match the tags: ^METRICS_(PATH|PORT|NAME)\w+$
    "MetricsPathPortTagPrefix": "METRICS_"
  },
  "AWS": {
    "Region": "us-west-2"
  },
  "Serilog": {
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware": "Information",
        "System": "Warning",
        "Amazon": "Warning"
      }
    },
    "WriteTo": [
      {
        "Name": "Console",
        "Args": {
          "outputTemplate": "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u3}] {Message:lj}{NewLine}{Exception}"
        }
      }
    ]
  },
  "AllowedHosts": "*"
}
